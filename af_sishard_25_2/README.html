<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>AF SisHard 25-2</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">AF SisHard 25-2</h1>
</header>
<!-- markdown_py README.md > README.html -->
<!-- pandoc README.md -f markdown -t html -s -o README.html --metadata title="AF SisHard 25-2" -->
<h1 id="avaliação-final-de-sistemas-hardware-software">Avaliação Final
de Sistemas Hardware-Software</h1>
<p>Neste prova iremos avaliar os objetivos de aprendizagem trabalhados
na segunda metade do curso. Cada pasta contém os arquivos de uma questão
da prova, incluindo arquivos <code>.c</code> para vocês colocarem suas
soluções.</p>
<h2 id="regras-da-prova">Regras da prova</h2>
<ol type="1">
<li><p>É permitido consultar o material da disciplina durante a prova
(repositório da disciplina e seu repositório de atividades), além de
seus materiais físicos, a calculadora nativa do Ubuntu e os links de
sites presentes nas aulas, veja a página de dicas da disciplina.
<strong>Ficam proibidas consultas a materiais de outros alunos ou
qualquer forma de IA (sujeito a código de ética).</strong></p></li>
<li><p>Durante a prova não é permitido consultar outras pessoas, sejam
do Insper ou não. Não abra E-mail, Whatsapp, Discord, etc.</p></li>
<li><p>A chamada na prova será realizada pela assinatura na lista de
prensença. Não saia sem assinar a lista.</p></li>
<li><p>Não serão tiradas dúvidas do conteúdo da disciplina durante a
prova.</p></li>
<li><p>A entrega da sua prova deverá ser feita via Blackboard.
<strong>Não serão aceitas entregas por outros meios</strong>.</p></li>
<li><p>As questões da prova <strong>serão avaliadas por um corretor
automático</strong>, um executável disponível na pasta de cada questão
(<code>./teste</code>). Esse executável corrige a resposta utilizando
uma rubrica incremental, na qual as funcionalidades devem ser
implementadas em sequência. Para que uma funcionalidade seja validada, é
necessário que todas as anteriores também tenham sido concluídas
corretamente. Quanto maior o número de funcionalidades atendidas, maior
será a nota.</p></li>
<li><p><strong>IMPORTANTE</strong>: nessa disciplina fica proibido o uso
de de ferramentes de auxílio para geração de código (IA) <strong>copilot
(se tiver instalado desinstale)</strong> e o uso de ferramentas de
<strong>geração de código automático por IA</strong> (por
exemplo:<strong>ChatGPT</strong>), pois é esperado que atividade
intelectual seja realizada exclusivamente pelo o aluno, o não
atendimento dessa restrição implica em <strong>nota 0,0</strong> e
código de ética.</p></li>
</ol>
<h2 id="antes-de-começar-a-resolver">Antes de começar a resolver</h2>
<ul>
<li><p>Faça o download do arquivo <em>zip</em> da pasta e descompacte em
alguma pasta no seu computador, não é necessário salvar os arquivos no
seu repositório. Ao final <strong>rezip</strong> a pasta inteira e
<strong>faça upload no Blackboard</strong>.</p></li>
<li><p>Caso atenda todas as rubricas da questão, o executável de teste
(<code>./teste</code>), terá com saída um <strong>PASS</strong> com a
nota da questão, que significa que o programa de teste não encontrou
problemas em sua solução (não que ela esteja correta!), depois da
entrega será feito uma validação extra pelo professor, envolvendo por
exemplo:</p>
<ul>
<li><p>Verificar o uso de funções não permitidas, que poderá resultar na
anulação da nota no exercício.</p></li>
<li><p>Os testes pegam apenas alguns casos, garanta que sua solução
funciona conforme o requisitado no enunciado.</p></li>
<li><p>Se passou nos testes mas a solução está errado, a nota será
desconsiderada.</p></li>
<li><p><strong>Tentativas de burlar os testes resultarão em zero na
prova</strong>.</p></li>
</ul></li>
</ul>
<hr />
<h2 id="questão-1-25">Questão 1 (2,5)</h2>
<style scoped>section { font-size: 20px; }</style>
<p>A figura <em>q1/sincronizacao.png</em> ilustra as relações de
dependência entre as partes das funções
<code>thread1, thread2, thread3</code> e <code>thread4</code>, mostrando
que algumas delas poderiam ser feitas de maneira concorrente.</p>
<p><img src="q1/sincronizacao.jpg" /></p>
<p>Seu trabalho nesta questão será:</p>
<ol type="1">
<li><p>criar threads para <strong>execução concorrente</strong> dos
prints das funções. (<strong>40% da nota</strong>).</p></li>
<li><p><strong>usar semáforos</strong> para que a <strong>ordem e
concorrência</strong> dos prints das partes das tarefas respeitem o
diagrama da figura. (<strong>60% da nota</strong>).</p></li>
</ol>
<p><strong>OBS</strong>:</p>
<ul>
<li><p>Você não deve introduzir novas dependências ou travar a saída com
semafóros de forma que seu programa tenha uma única saída; o seu
programa deve permitir impressões concorrentes, por exemplo, para figura
<em>q1/sincronizacao.png</em> são possíveis, entre outras, as saídas:
<code>ABCDEFG</code>, <code>BACDEFG</code>, <code>ABDCEFG</code>,
<code>BADCGFE</code>, <code>BADCGFE</code>…..</p></li>
<li><p>Não altere os <code>printf</code> existentes, nem adicione
novos.</p></li>
<li><p>A nota da questão virá pelos testes automáticos e a análise
visual pelo professor será apenas para confirmar que nenhuma regra foi
quebrada!</p></li>
<li><p><strong>Importante: Caso use variáveis globais na solução da
questão a nota será zero (mesmo que passe nos testes).</strong></p></li>
</ul>
<p><strong>Como descrubro minha nota?</strong>:</p>
<p>Execute o corretor automático do exercício.</p>
<pre><code>./teste</code></pre>
<hr />
<h2 id="questão-2-25">Questão 2 (2,5)</h2>
<p>Nessa questão desenvolva o programa <code>q2.c</code> que encontra o
<strong>maior</strong> elemento no vetor <code>A[]</code> de inteiros
com <code>n</code> posições.</p>
<p>O seu programa deve criar <code>K</code> processos filhos sendo, cada
um deles, responsável por procurar em uma região <code>R</code> do
vetor.</p>
<p>O <strong>maior</strong> elemento encontrado pelo processo filho na
sua região <code>R</code> deve ser devolvido (retornado) ao processo
pai, que consolida o resultado comparando os maiores elementos
retornados por todos os processos filhos; ao final, processo pai imprime
a <strong>ordem do processo</strong> (<code>P0</code>, <code>P1</code>,
<code>P2</code>, … ) que encontrou o maior elemento e o maior elemento
no vetor <code>A[]</code>. Caso mais de um filho tenha encontrado o
<strong>maior</strong> o processo pai escolhe o <strong>filho de ordem
menor</strong>.</p>
<p>Por exemplo considere o arquivo de entrada <code>in4.txt</code>.</p>
<pre><code>
2 
4 
38
10
4
3
</code></pre>
<p>A primeira linha do arquivo informa a quantidade de processos filhos
que serão criados <code>K</code>e a segunda linha a quantidade de
números no arquivo <code>N</code>, assim cada processo deverá trabalhar
em uma região <code>R</code> de tamanho <code>2</code> (porque
<code>N/K = 4/2 = 2</code>).</p>
<p>Para a entrada acima o processo pai deve mostrar a mensagem
<strong><code>P0 maior=38</code></strong> informando que o maior
elemento no vetor é número <code>38</code> e foi encontrado pelo
processo de ordem <code>0</code>. Na pasta da questão <code>./q2</code>
colocamos alguns arquivos de testes, mas você pode criar os seus, para
validar a solução.</p>
<p>Seu trabalho nesta questão será:</p>
<ol type="1">
<li><p>criar <code>K</code> processos filhos para executar a busca do
maior elemento no vetor <code>A[]</code> em paralelo. Os
<strong>processos filhos devem esperar <code>5</code> segundos</strong>
antes de iniciar a busca (apenas os filhos esperam, o <strong>pai
não!</strong>). (<strong>40% da nota</strong>)</p></li>
<li><p>Processo pai imprime corretamente a ordem do processo que
encontrou e o maior valor, com a mensagem <code>"P%d maior=%d\n"</code>,
substituindo o primeiro <code>%d</code> pela ordem do filho e o segundo
<code>%d</code> pelo maior elemento no vetor. (<strong>40% da
nota</strong>)</p></li>
<li><p>Programa passa no <em>valgrind</em> sem erros. Aqui, também será
necessário liberar memórias alocadas na main no código que recebeu
pronto! (<strong>20% da nota</strong> apenas se resolveu corretamente os
anteriores).</p></li>
</ol>
<p>Para compilar o seu programa use:</p>
<pre><code>gcc q2.c -o q2</code></pre>
<p>Exemplo de como seu programa <code>q2</code> será chamado:</p>
<pre><code>./q2 &lt; in4.txt</code></pre>
<p>Para testar usando <em>valgrind</em> use:</p>
<pre><code>valgrind --leak-check=yes ./q2 &lt; in4.txt</code></pre>
<p><strong>Restrições</strong>:</p>
<ul>
<li><p>Os valores no vetor <code>A[]</code> estarão sempre entre
<code>0</code> até <code>255</code></p></li>
<li><p>Considere que <code>N % K = 0</code>;</p></li>
<li><p><strong>Importante</strong>: o seu programa principal (pai) deve
obrigatoriamente finalizar retornando 0
(<code>return 0</code>).</p></li>
</ul>
<p><strong>Como descrubro minha nota?</strong>:</p>
<p>Execute o corretor automático do exercício.</p>
<pre><code>./teste</code></pre>
<hr />
<h2 id="questão-3-25">Questão 3 (2,5)</h2>
<p>Abra o arquivo <code>q3.c</code>!</p>
<p>Uma nova funcionalidade foi requisitada nesta aplicação e você é o
responsável por implementá-la: gerar log de inicialização e finalização
do programa, de modo que quando o usuário desejar fechar a aplicação,
isto seja registrado em um arquivo de texto.</p>
<p>Sua tarefa neste exercício é:</p>
<ol type="1">
<li><p>Ao inicializar a aplicação com <code>./q3 logfile.txt</code>,
adicionar ao arquivo de log <code>logfile.txt</code> uma nova linha
contendo uma mensagem conforme o exemplo <code>./q3 iniciado\n</code>.
Se o arquivo de log não existir, deve ser criado (<strong>20% da
nota</strong>).</p></li>
<li><p>Se ao inicializar a aplicação e o arquivo de log já existir, ele
não deve ser sobrescrito, as mensagens de log são escritas no final
arquivo (<strong>10% da nota</strong>). <strong>DICA</strong>: veja os
flags da função <code>open()</code> em <code>man 2 open</code>.</p></li>
<li><p>Ao receber um sinal <strong>SIGTERM</strong> (15), adicionar ao
arquivo de log uma nova linha contendo uma mensagem conforme o exemplo
<code>./q3 finalizado\n</code> e a aplicação é finalizada. (<strong>30%
da nota pelo registro do handler e pela mensagem no
arquivo</strong>).</p></li>
<li><p>Ao receber um sinal <strong>SIGINT</strong> (2), adicionar ao
arquivo de log uma nova linha contendo uma mensagem conforme o exemplo
<code>./q3 nao finalizado com SIGINT\n</code>, nesse caso a aplicação
não é finalizada. (<strong>20% da nota pelo registro do handler e pela
mensagem na saída padrão</strong>)</p></li>
<li><p>O programa sai com o mesmo sinal que recebeu. (<strong>20% da
nota</strong>)</p></li>
</ol>
<p><strong>OBS</strong>:</p>
<ul>
<li><p>Você deve criar as funções para serem handlers dos
sinais</p></li>
<li><p>Os Handlers devem ser registrados na <code>main</code></p></li>
<li><p>Perceba que o nome do arquivo de log é passado pela linha de
comando, nem sempre será <code>logfile.txt</code>.</p></li>
<li><p>Para manipular o arquivo de log, utilize APENAS as chamadas do
padrão POSIX conforme apresentado em aula: <code>open</code>,
<code>close</code>, <code>read</code>, <code>write</code>. Não pode
utilizar <code>fopen</code>, <code>fdopen</code>,<code>fgets</code>,
<code>fscanf</code> por exemplo.</p></li>
</ul>
<p>Para testar sua implementação você pode compilar o seu programa
com:</p>
<pre><code>gcc q3.c  -g -o q3</code></pre>
<p>E envie sinais pelo terminal e confira o arquivo de log gerado!</p>
<pre><code>kill -&lt;codigo do sinal&gt; &lt;pid do processo&gt;</code></pre>
<p><strong>Como descrubro minha nota?</strong>:</p>
<p>Execute o corretor automático do exercício.</p>
<pre><code>./teste</code></pre>
<hr />
<h2 id="questão-4-25">Questão 4 (2,5)</h2>
<p>Nos labs <code>02</code> e <code>03</code>desse semestre vimos o quão
necessário é saber manipular <strong>strings</strong> e
<strong>arquivos</strong> na linguagem <strong>C</strong>.</p>
<p>Nesta questão o seu trabalho será escrever um programa que recebe o
nome de dois arquivos por linha de comando; os arquivos contêm palavras
separadas por <code>\n</code>, a exceção é a última linha que não tem
<code>\n</code>, em seguida seu programa deve intercalar o conteúdo dos
arquivos no arquivo <strong><code>q4_saida.txt</code></strong>.</p>
<p>Para a chamada do programa:</p>
<pre><code>./q4 caso1.txt caso2.txt</code></pre>
<p>Teríamos a seguinte saída no arquivo <code>q4_saida.txt</code>.</p>
<table>
<thead>
<tr class="header">
<th>caso1.txt</th>
<th>caso2.txt</th>
<th>q4_saida.txt</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>carlos</td>
<td>caju</td>
<td>carlos</td>
</tr>
<tr class="even">
<td>ana</td>
<td>uva</td>
<td>caju</td>
</tr>
<tr class="odd">
<td></td>
<td>pera</td>
<td>ana</td>
</tr>
<tr class="even">
<td></td>
<td>caqui</td>
<td>uva</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>pera</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>caqui</td>
</tr>
</tbody>
</table>
<p>Note que o processo de intercalação das palavras lidas começa com a
palavra lida do 1<sup>o</sup> arquivo e caso um dos arquivos termine
primeiro, o programa copia as palavras restantes do outro arquivo para o
arquivo de saída. Na pasta da questão <code>./q4</code> colocamos alguns
arquivos de testes, mas você pode criar os seus, para validar a
solução.</p>
<p><strong>IMPORTANTE</strong>: a <strong>última linha</strong> do
arquivo de saída também <strong>não possui <code>\n</code></strong> e
sempre teremos pelo menos uma palavra nos arquivos de entrada.</p>
<p>A sua tarefa nessa questão está dividida em três partes:</p>
<ol type="1">
<li><p>A primeira é programar a função
<code>char *le_palavra(int fd)</code> que retorna uma string contendo
uma palavra lido do arquivo texto apontado por <code>fd</code>, caso o
arquivo tenha chegado ao fim a função dever retornar <code>NULL</code>.
Considere que a função já recebe o arquivo que já foi aberto no
<code>main()</code>, e é obrigatório utilizar apenas a chamada da
função<code>read</code> para ler os caracteres do arquivo, ou seja, não
permito usar a função <em>getline</em> por exemplo <strong>(30% da
nota)</strong>.</p></li>
<li><p>Utilizando a função <code>char *le_palavra(int fd)</code> o
programa gera o arquivo <code>q4_saida.txt</code> contendo as linhas dos
arquivos de entrada intercaladas. (<strong>50% da
nota</strong>)</p></li>
<li><p>Programa passa no <em>valgrind</em> sem erros. (<strong>20% da
nota</strong>, apenas se resolveu corretamente os itens
anteriores).</p></li>
</ol>
<p>Para compilar:</p>
<pre><code>gcc q4.c -o q4</code></pre>
<p>Para testar usando <em>valgrind</em> use:</p>
<pre><code>valgrind --leak-check=yes ./q4 caso1.txt caso2.txt</code></pre>
<p><strong>OBS</strong>:</p>
<ul>
<li><p>Para manipular o arquivo de log, utilize APENAS as chamadas do
padrão POSIX conforme apresentado em aula: <code>open</code>,
<code>close</code>, <code>read</code>, <code>write</code>. Não pode
utilizar <code>fopen</code>, <code>fdopen</code>,<code>fgets</code>,
<code>fscanf</code> por exemplo. Se utilizar, a nota do exexcício será
zero (mesmo que passe nos testes).</p></li>
<li><p>Precisa funcionar para qualquer código fonte, se tiver testes
fixos apenas para burlar os testes, irá zerar!</p></li>
<li><p>A nota da questão virá pelos testes automáticos e
<em>valgrind</em>. A análise visual pelo professor para verificar se a
função <code>char *le_palavra(int fd)</code> foi implementada conforme
especificação e validar se nenhuma regra foi quebrada!</p></li>
</ul>
<p><strong>Como descrubro minha nota?</strong>:</p>
<p>Execute o programa abaixo para testar sua solução</p>
<pre><code>./teste</code></pre>
<hr />
</body>
</html>
